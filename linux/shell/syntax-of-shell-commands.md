# Syntax of Shell Commands

A commands issues in the shell generally consists of a command name followed by arguments. Technically referee to as fields.&#x20;

* **Command name**: This is the first word of the command, and normally represents either an executable file somewhere in the filesystem or a shell builtin. However, it can also represent a function.&#x20;
  * **Executable file**: executable program somewhere in the file system. either an OS utility program or a user-written program. It's located on the filesystem in an executable. Examples include `ls`, `ssh`, `emacs`, `javac`, `java`, `python`, `gcc`, and so on. The shell attempts to locate this program based on the PATH environment variable or an absolute/relative path if provided. The only difference is whether you have to supply a pathname
  * **Shell Built-in**: A utility implemented within the shell. These include commands like `cd`, `echo`, `exit`, `alias`, `set`, and many others.
* **Argument**: An argument is a parameter passed to a utility represented by command name.  An argument is typically an option or an operand.
  * **Option**: An option is generally used to specify changes in the utility's default behavior
  * **Operand**: An option generally specifies the data to be manipulated or operated on. An operand might represent a filename, a literal, or a variable.&#x20;

Typically several options and sometimes even several operands can be supplied. The structure is illustrated in Figure X.&#x20;



<figure><img src="../../.gitbook/assets/Screenshot 2023-05-19 at 4.10.11 PM.png" alt="" width="375"><figcaption><p>Figure X: Hierarchy of command components</p></figcaption></figure>



## Example of commands:&#x20;

### Shell prompt

Every shell displays a prompt on the command line. On armlab, the shell prompt looks like the following:

<figure><img src="../../.gitbook/assets/Screenshot 2023-04-25 at 3.08.46 PM.png" alt=""><figcaption></figcaption></figure>

The prompt is generated by Bash, indicating its readiness to accept a command. It also provides useful information, such as the hostname of the computer you are logged into (armlab01 or armlab02), the working directory you are currently in (by default your home directory, which is represented by [\~](../../bash/useful-command-line-features.md#tilde-expansion)), and your access level ($ for ordinary users, # for the system administrator). Generalizing, the Bash prompt on armlab has the following format:&#x20;

<figure><img src="../../.gitbook/assets/Screenshot 2023-04-25 at 3.08.28 PM.png" alt=""><figcaption></figcaption></figure>



Let's begin by breaking down commands you're already familiar with.&#x20;

```bash
javac hello.java
```

`javac` is the Java compiler that translates Java source code into Java Bytecode. The shell interprets `javac` as an executable program, and `hello.java` as the argument to this program. The shell uses a system call to create a new process and then loads the `javac` program into the new process's memory. `javac` then reads the `hello.java` file and compiles it into Java Bytecode, creating a file named `Hello.class`.

Let's begin by breaking down commands you're already familiar with.&#x20;

```bash
java Hello 
```

`java` is the Java Runtime Environment (JRE) that executes Java Bytecode. The shell interprets `java` as an executable program, and `Hello` as the argument to this program. The shell uses a system call to create a new process and then loads the `java` program into the new process's memory. `java` then reads the H`ello.class` file and executes the Java Bytecode contained within.

```bash
gcc217 hello.c -o hello
```

`gcc` is the GNU Compiler Collection, a compiler for various programming languages including C. The shell interprets `gcc` as an executable program, and `hello.c`, `-o`, and `hello` as arguments to this program. The shell uses a system call to create a new process and then loads the `gcc` program into the new process's memory. `gcc` then reads the `hello.c` file and compiles it into an executable file named `hello`.

```bash
./hello
```

* `./hello` is a command to execute the `hello` program in the current directory. The `.` in `./` specifies the current directory, and `/hello` is the program to run. The shell uses a system call to create a new process and then loads the `hello` program into the new process's memory. The `hello` program then runs.

.
