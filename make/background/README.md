# Background

1. Review of the 4 stage compilation proccess.&#x20;
2. You might wonder why the compiler goes through all the trouble. Truthfully, the assembly phase doesn't serve any strong purpose. It's just how GCC was designed. Other compilers skip that step, only doing it if you explicitly request.&#x20;
3. The steps we will focus on are the preprocessing step and the linking step. What is the point of them? Why not just go from source code directly to an executable? What is the point of the preproccessing
4. What if you want to reu'se&#x20;

<figure><img src="../../.gitbook/assets/Group 65.png" alt="" width="563"><figcaption></figcaption></figure>

1.
2.
3.
4. The purpose of Make is to make compiling multi-file programs easier. Understanding the challenges of compiling multi-file programs
5. To understand this, we need to back up and review some of the fundamentals of how compiling works in C. Specificaly, it's important that you understand the concept of "seperate compilation" and how it works in C
6. Suppose we have a C program consisting of two files, f1.c and f2.c. To compile and run the program with gcc217, we can invoke: gcc217 f1.c f2.c, which will generate an executable named a.out. (You can also choose a custom name for the executable by supplying the -o option.)
7. The content of the executable was generated by merging the contents of f1.c and f2.c.  How exactly does the merging take place? There are two ways to&#x20;
8. We know that the compiler took two files-f1.c and f2.c--and generated a single output file--the a.out executable. Obviously, at some point the contents of f1.c and f2.c had to be combined. There are two ways we can envision the combining happening. Method 1: the compiler combined the _source code_ of f1.c and f2.c into a single unit and then compiled the single unit into the executable. compiled the source code as a single to generate the a.out executable. Method 2: the compiler first compiled the source code of f1.c and f2.c _individually_ and only after each one was compiled  combined the output of each to generate the a.out executable. Both methods are shown in figure 1.&#x20;
9. You might think that the distinction is immaterial. Who cares how the compiler does it, so long as it generates an executable? But the distinction actually has major implications.&#x20;
10. Let's briefly examine the pros and cons of each approach:&#x20;
11. As you can probably guess, GCC uses method two. That is, it compiles each files source code separately, only after each source file is compiled does it merge them all together to create an executable. &#x20;
12.































1. We'll start by reviewing the easiest case, which is the proccess of compiling a a single, self-contained file, and work our way up to compiling a multi-file project.&#x20;
2.  Suppose Suppose we have the C program _intmath.c,_ that prompts the user for two integers and outputs their greatest common divisor (gcd) and least common multiple (lcm):

    ```c
    /*--------------------------------------------------------------------*/
    /* intmath.c                                                          */
    /*--------------------------------------------------------------------*/

    #include <stdio.h>

    int gcd(int i, int j) {
        int temp;
        while (j != 0) {
            temp = i % j;
            i = j;
            j = temp;
        }
        return i;
    }

    int lcm(int i, int j) {
        return (i / gcd(i, j)) * j;
    }

    int main(void) {
        int i, j;
        printf("Enter the first integer:\n");
        scanf("%d", &i);
        printf("Enter the second integer:\n");
        scanf("%d", &j);
        printf("Greatest common divisor: %d.\n", gcd(i, j));
        printf("Least common multiple: %d.\n", lcm(i, j));
        return 0;
    }

    ```

    To compile _intmath.c_ with gcc217, we can use the following command: `gcc217 intmath.c -o intmath`
3.  This compiles the source code in _intmath.c_ to machine code and stores it in an executable file named _intmath_. To run _intmath_, we can invoke it like so:&#x20;

    ```bash
    ~> ./intmath
    Enter the first integer:
    3
    Enter the second integer:
    4
    Greatest common divisor: 1.
    Least common multiple: 12.
    ~> 
    ```
4. doing this was easy, since all the source code needed to produce the executable was contained in intmath.c. (That's not exactly true, since the program makes library calls--printf() and scans()--but we'll ignore that fore now, since the compiler takes care of that for us.)
5. &#x20;In practice, however, it's not usually quite that simple, because it's usually inconvenient to put your entire program's source code into a single file. Particulurly when projects grow in size, you'll want to separate your own source code into several files, because smaller files are easier to work with and allow for better organization of your code.
6. Suppose we want to split up the source code of intmath.c into two files. We'll keep the implementation of the gcd and lcm functions in intmath.c, but we want to move the main function, which essentially serves as the client code that calls the functions, into another file called testintmath.c.
7. Unfortunately, splitting up intmath.c in this manner isn't as simple as keeping the gcd and lcm functions in intmath.c and and pasting the rest of it into testintmath.c. To see why, let's try to do just that.&#x20;
8. In the following code, we keep the gcd and lcm functions in intmath.c and paste the rest into testintmath.c.



```c
/*--------------------------------------------------------------------*/
/* intmath.c                                                          */
/*--------------------------------------------------------------------*/

int gcd(int i, int j)
{
   int temp;
   while (j != 0) {
     temp = i % j;
     i = j;
     j = temp;
}
return i; }

int lcm(int i, int j)
{
   return (i / gcd(i, j)) * j;
}

```

```c
/*--------------------------------------------------------------------*/
/* testintmath.c                                                      */
/*--------------------------------------------------------------------*/

#include <stdio.h>

int main(void)
{
int i, j;
printf("Enter the first integer:\n"); scanf("%d", &i);
printf("Enter the second integer:\n"); scanf("%d", &j);
printf("Greatest common divisor: %d.\n", gcd(i, j));
printf("Least common multiple: %d.\n", lcm(i, j));
return 0; 
}

```



Now let's try to run testintmath.c, which we hope will prompt the user for two integers and output the lcd and gcd. When we try to compile intmath.c, we get the following two errors:&#x20;

```bash
~> gcc217 testintmath.c -o intmath
testintmath.c:9:42: error: implicit declaration of function 'gcd' [-Werror,-Wimplicit-function-declaration]
printf("Greatest common divisor: %d.\n", gcd(i, j));
                                         ^
testintmath.c:10:40: error: implicit declaration of function 'lcm' [-Werror,-Wimplicit-function-declaration]
printf("Least common multiple: %d.\n", lcm(i, j));
                                       ^
2 errors generated.
~> 
```



expain the problem.&#x20;

## Solution 1

As a solution, we can use the #include preproccesor directive:

```c
/*--------------------------------------------------------------------*/
/* testintmath.c                                                      */
/*--------------------------------------------------------------------*/

#include <stdio.h>
#include "intmath.c"

int main(void)
{
int i, j;
printf("Enter the first integer:\n"); scanf("%d", &i);
printf("Enter the second integer:\n"); scanf("%d", &j);
printf("Greatest common divisor: %d.\n", gcd(i, j));
printf("Least common multiple: %d.\n", lcm(i, j));
return 0; 
}

```

Now when we compile the program, everything will work.

This solution essentially does the following: testintmath.c gets sent to the preprocessor. The preproccesor adds the contents of intmath.c to testintmath.c, right where the #include "intmath.c" statement is. The preproccessed file is then compiled into a n object file, linked, and an executable is generated.&#x20;

### Solution 2

While solution 1 works, it has one major drawback: the contents of both intmath.c and testintmath.c are compiled together. However, it is preferable for them to be compiled seperately. Why? Because if they're compiled seperately and then we edit intmath.c, only intmath.c needs to be recompiled.&#x20;



The main program also includes the header file ‘intmath.h’ which will contain the declaration of the function hello. The declaration is used to ensure that the types of the arguments and return value match up correctly between the function call and the function definition.

We no longer need to include the system header file ‘stdio.h’ in ‘main.c’ to declare the function printf, since the file ‘main.c’ does not call printf directly.

To compile these source files with gcc217, use the following command:&#x20;

```bash
gcc intmath.c testintmath.c -o intmath
```

Note that the header file ‘intmath.h’ is not specified in the list of files on the command line. The directive #include "intmath.h" in the source files instructs the compiler to include it automatically at the appropriate points.

All the parts of the program have been combined into a single executable file, intmath, which produces the same result as the executable created from the single source file used earlier.

###

###

```
/*--------------------------------------------------------------------*/
/* intmath.h                                                          */
/*--------------------------------------------------------------------*/

#ifndef INTMATH_INCLUDED 
#define INTMATH_INCLUDED 
int gcd(int i, int j); 
int lcm(int i, int j); 
#endif
```

###

### Compiling files independently

If a program is stored in a single file then any change to an individual function requires the whole program to be recompiled to produce a new executable. The recompilation of large source files can be very time- consuming.

When programs are stored in independent source files, only the files which have changed need to be recompiled after the source code has been modified. In this approach, the source files are compiled separately and then linked together—a two stage process. In the first stage, a file is compiled without creating an executable. The result is referred to as an object file, and has the extension ‘.o’ when using GCC.

In the second stage, the object files are merged together by a separate program called the linker. The linker combines all the object files together to create a single executable.

An object file contains machine code where any references to the memory addresses of functions (or variables) in other files are left undefined. This allows source files to be compiled without direct reference to each other. The linker fills in these missing addresses when it produces the executable.

### Creating object files from source files

The command-line option ‘-c’ is used to compile a source file to an object file. For example, the following command will compile the source file ‘intmath.c’ to an object file:

```
gcc217 -c intmath.c
```

This produces an object file ‘intmath.o’ containing the machine code for the main function. It contains a reference to the external function hello, but the corresponding memory address is left undefined in the object file at this stage (it will be filled in later by linking).

The corresponding command for compiling the hello function in the source file ‘testintmath.c’ is:

```
gcc217 -c testintmath.c
```

This produces the object file ‘testintmath.o’.

Note that there is no need to use the option ‘-o’ to specify the name of the output file in this case. When compiling with ‘-c’ the compiler automatically creates an object file whose name is the same as the source file, with ‘.o’ instead of the original extension.

There is no need to put the header file ‘intmath.h’ on the command line, since it is automatically included by the #include statements in ‘intmath.c’ and ‘testintmath.c’.

### Creating executables from object files

The final step in creating an executable file is to use gcc to link the object files together and fill in the missing addresses of external functions. To link object files together, they are simply listed on the command line:

```
    $ gcc main.o hello_fn.o -o hello
```

This is one of the few occasions where there is no need to use the ‘-Wall’ warning option, since the individual source files have already been success- fully compiled to object code. Once the source files have been compiled, linking is an unambiguous process which either succeeds or fails (it fails only if there are references which cannot be resolved).

To perform the linking step gcc uses the linker ld, which is a separate program. On GNU systems the GNU linker, GNU ld, is used. Other systems may use the GNU linker with GCC, or may have their own linkers. The linker itself will be discussed later (see Chapter 11 \[How the compiler works], page 81). By running the linker, gcc creates an executable file from the object files.

The resulting executable file can now be run:

```
    $ ./hello
    Hello, world!
```

It produces the same output as the version of the program using a single source file in the previous section.

### Recompiling and relinking

To show how source files can be compiled independently we will edit the main program ‘main.c’ and modify it to print a greeting to everyoneinstead of world:

```
      #include "hello.h"
```

```
      int
      main (void)
      {
```

```
        hello ("everyone");  /* changed from "world" */
```

return 0; }

The updated file ‘main.c’ can now be recompiled with the following com- mand:

```
    $ gcc -Wall -c main.c
```

This produces a new object file ‘main.o’. There is no need to create a new object file for ‘hello\_fn.c’, since that file and the related files that it depends on, such as header files, have not changed.

The new object file can be relinked with the hello function to create a new executable file:

$ gcc main.o hello\_fn.o -o hello\
The resulting executable ‘hello’ now uses the new main function to pro-

duce the following output:

```
    $ ./hello
    Hello, everyone!
```

Note that only the file ‘main.c’ has been recompiled, and then relinked with the existing object file for the hello function. If the file ‘hello\_fn.c’ had been modified instead, we could have recompiled ‘hello\_fn.c’ to create a new object file ‘hello\_fn.o’ and relinked this with the existing file ‘main.o’.(1)

In general, linking is faster than compilation—in a large project with many source files, recompiling only those that have been modified can make a significant saving. The process of recompiling only the modified

(1) If the prototype of a function has changed, it is necessary to modify and recompile all of the other source files which use it.

files in a project can be automated using GNU Make&#x20;











































Suppose we want to write a program that calculates the greatest common divisor and least common multiple of two integers. We create a file named intmath.c and write two functions in it--one for gcd, and one for lcd.&#x20;

```c
/*--------------------------------------------------------------------*/
/* intmath.c                                                          */
/*--------------------------------------------------------------------*/

int gcd(int i, int j)
{
   int temp;
   while (j != 0) {
     temp = i % j;
     i = j;
     j = temp;
}
return i; }

int lcm(int i, int j)
{
   return (i / gcd(i, j)) * j;
}

```

To test our implementation, we create another file named testintmath.c that prompts the user for two integerts, calls the gcd and lcm functions, and outputs the answers to the user.

```c
/*--------------------------------------------------------------------*/
/* testintmath.c                                                      */
/*--------------------------------------------------------------------*/

#include <stdio.h>

int main(void)
{
int i, j;
printf("Enter the first integer:\n"); scanf("%d", &i);
printf("Enter the second integer:\n"); scanf("%d", &j);
printf("Greatest common divisor: %d.\n", gcd(i, j));
printf("Least common multiple: %d.\n", lcm(i, j));
return 0; 
}

```

You then try to compile testintmath.c using gcc217, but to your dismay, you get the following errors:

```bash
~> gcc217 testintmath.c -o testintmath
testintmath.c:8:42: error: implicit declaration of function 'gcd' [-Werror,-Wimplicit-function-declaration]
printf("Greatest common divisor: %d.\n", gcd(i, j));
                                         ^
testintmath.c:9:40: error: implicit declaration of function 'lcm' [-Werror,-Wimplicit-function-declaration]
printf("Least common multiple: %d.\n", lcm(i, j));
                                       ^
2 errors generated.
~> 
```

The exact meaning of these error messages is not clear to you, but you know it has something to do with the parts that call the gcd and lcm functions. You then realize, of course the program won't work--gcd and lcm are not defined anywhere in testinmath.c! So when you try to compile it, the compiler doesnt have a clue what gcd and lcm are!

solution 1: bad

Simple add the code for gcd and lcm into the testintmath.c program, above the main function. This is obviouslyt n ot a great solution, as it defeatsa the purpose of creating two seperate files--to make your program more modular!&#x20;



Solution two: better

You include the intmath.c code via a preproccesor directive--namely, by adding #include "intmath.c" at the top of your file. This way, you don;'t have to manulally copy and paste all the code. Instead, whenmeverrt you want to use it, you let the preproccessor do the work.

<pre class="language-c"><code class="lang-c">/*--------------------------------------------------------------------*/
/* testintmath.c                                                      */
/*--------------------------------------------------------------------*/

#include &#x3C;stdio.h>
<strong>#include "intmath.c" /* you add the following line*/
</strong>

int main(void)
{
int i, j;
printf("Enter the first integer:\n"); scanf("%d", &#x26;i);
printf("Enter the second integer:\n"); scanf("%d", &#x26;j);
printf("Greatest common divisor: %d.\n", gcd(i, j));
printf("Least common multiple: %d.\n", lcm(i, j));
return 0; 
}
</code></pre>

Solution 3: You&#x20;
