# Example: Single-file Program

Let's walk through the four-stage process of building a program in practice. As an example, we'll use the `charcount` program. Instead of using the all-in-one shortcut command to build it, we'll invoke each stage individually, similar to what happens under the hood.

{% code title="charcount.c" %}
```c
#include <stdio.h>

/* Write to stdout the number of chars in stdin. Return 0. */
int main(void) {
    int c;
    int charCount = 0;

    c = getchar();
    while (c != EOF) {
        charCount++;
        c = getchar();
    }

    printf("%d\n", charCount);
    return 0;
}
```
{% endcode %}

### Preprocessing

The first step to building our program is to preprocess it. The command to invoke the preprocessor is:

```bash
gcc217 -E charcount.c -o charcount.i
```

The result is the preprocessed file `charcount.i`. As we mentioned earlier, the preprocessor performs two main tasks: It removes comments, which are of no use to the compiler, and handles preprocessor directives (lines in the code that begin with a `#`). `charcount.c` has only a single preprocessor directive: `#include <stdio.h>`. This directive instructs the preprocessor to grab the contents of `stdio.h` and paste it directly in the spot in `charcount.c` where the `#include` directive appears. stdio.h is a system header file representing an interface for standard I/O functions. We'll get into the details in the next section, but for now, all you need to know is that whenever a program uses functionality from C standard I/O, it needs to #include stdio.h in it.

The entire file is quite large, containing somewhere on the order of 1000 lines. It contains declarations of standard I/O functions, such as printf.

```c
int printf(const char *format, ...);
```

Additionally, it contains the definition of EOF.

```c
#define EOF -1
```

You can view the preprocessed output in `charcount.i` using a text editor like emacs. It should look something like this:

{% hint style="success" %}
You can think of the preprocessor as a "search-and-replace" tool:

* It replaces each comment with a whitespace character.
* It replaces each `#include` directive with the contents of the specified file.
* It replaces each macro with its value.
{% endhint %}

### Compilation

The next step is to run the compiler on `charcount.i`. We do so with the following command:

```
gcc217 -S charcount.i
```

The output is assembly language file `charcount.s`. Let's break down what takes place during this stage.

#### Error Checking

First, the compiler checks for syntax errors in our code. Syntax errors occur if you don’t follow the grammar rules of the C language. For example, forgetting a semicolon or a curly brace. Thankfully we don’t have any syntax errors, but if we did, the compiler would report the errors and terminate.

Next, the compiler checks for semantic errors. Semantic errors occur when the syntax is correct, but the code doesn't make sense. For example, using an undeclared variable or calling a function with the wrong number of arguments. An important part of semantic analysis is type checking, where the compiler checks for type compatibility in expressions and function calls. The compiler uses the declarations of `printf` and `getchar` that were inserted into our program during the preprocessing stage to ensure that the functions are called correctly.

#### Translation to Assembly

Assuming the compiler does not detect any errors in our program, it then translates it into assembly language. Assembly language is essentially a human-readable version of the target processor's machine language. As such, the precise assembly language generated by the compiler will depend on the architecture of the target processor. On an ARM64 machine, the assembly will look something like this:

{% code title="charcount.s" %}
```armasm
.LC0:
        .string "%d\n"
main:
        stp     x29, x30, [sp, -32]!
        mov     x29, sp
        str     wzr, [sp, 24]
        bl      getchar
        str     w0, [sp, 28]
        b       .L2
.L3:
        ldr     w0, [sp, 24]
        add     w0, w0, 1
        str     w0, [sp, 24]
        bl      getchar
        str     w0, [sp, 28]
.L2:
        ldr     w0, [sp, 28]
        cmn     w0, #1
        bne     .L3
        ldr     w1, [sp, 24]
        adrp    x0, .LC0
        add     x0, x0, :lo12:.LC0
        bl      printf
        mov     w0, 0
        ldp     x29, x30, [sp], 32
        ret
```
{% endcode %}

You don't need to understand what any of this means. ARM64 assembly will be covered in detail in the second half of COS217. For now, a few points are worth noting.

*   Each assembly instruction performs a very basic task, such as adding two numbers or moving data from one memory location to another. As such, it has a poor ratio of functionality to code size compared to higher-level languages like C. In our example, the simple statement getChar++ maps to four ARM assembly instructions:

    ```armasm
    LDR     w0, [sp, 24]
    ADD     w0, w0, 1
    STR     w0, [sp, 24]
    ```
* Assembly language gives you total control over the CPU. Some operations possible in assembly have no high-level language equivalent. This allows you to optimize performance and resource usage to a degree not possible in higher-level languages.
* One of the main drawbacks of assembly is that it's not portable. Unlike high-level languages like C, \<fill in>.
