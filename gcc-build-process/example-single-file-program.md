# Example: Single-file Program

Now that we have a high-level understanding of the four stage build process, let's walk through it using a real program as an example. Our example program will be the `charcount` program from lecture 3, whose source code is shown below. This program counts the number of characters input through stdin and outputs the count to stdout.

Instead of using the all-in-one shortcut command to build it (I.e., `gcc217 charcount.c -o charcount`), which performs preprocessing, compilation, assembly, and linking, we'll run each stage individually, similar to how it happens under the hood.

{% code title="charcount.c" %}
```c
#include <stdio.h>

/* Write to stdout the number of chars in stdin. Return 0. */
int main(void) {
    int c;
    int charCount = 0;

    c = getchar();
    while (c != EOF) {
        charCount++;
        c = getchar();
    }

    printf("%d\n", charCount);
    return 0;
}
```
{% endcode %}

#### The Starting Point

Our program begins as a C source file. We can roughly divide the source code into three categories: 

* Comment&#x20; Meant for human readers. 
* Preprocessing language, meant for preprocessor. The preprocessing language in our program consists of the #include <stdio> directive and the EOF macro. 
* Raw C code&#x20; Everything else. 


Of note is that our program make calls to two library functions: `printf` and `getchar`.&#x20;

### Preprocessing

The first step to building our program is to preprocess it. The command to invoke the preprocessor is:

```bash
gcc217 -E charcount.c -o charcount.i
```

The result is the preprocessed file `charcount.i`. Let's break down what the preprocessor does. 

1. removes the comment on lines <fill in> 
2. inserts the contents of stdio.h. the #include <stdio.h> directive tells the preprocessor to grab the contents of stdio.h (typically located in ) and paste it into our program right where the #include directive appears. stdio.h is a large file, containing function declarations and macro definitions. Of note to us is that it contains the declarations of printf and getChar, and it contains the definition of the EOF macro.&#x20;
3. Expands the EOF macro. 



```c
int printf(const char *format, ...);
int getChar(void);
```

```c
#define EOF -1
```

You can view the preprocessed output in `charcount.i` with a text editor like emacs. You'll find that the file has expanded significantly, typically to around 500-700 lines. Most of this additional content comes from `stdio.h` and includes various declarations and macro definitions that our program depends on.

{% code title="charcount.i" %}
```c
...
int printf(const char *format, ...);
int getChar(void);
...

int main(void) {
    int c;
    int charCount = 0;

    c = getchar();
    while (c != -1) {
        charCount++;
        c = getchar();
    }

    printf("%d\n", charCount);
    return 0;
}
```
{% endcode %}

At this point, our program contains raw C code only, which declarations of printf and getChar functions at the top.&#x20;

{% hint style="success" %}
You can think of the preprocessor as a "search-and-replace" tool:

* It replaces each comment with a whitespace character.
* It replaces each `#include` directive with the contents of the specified file.
* It replaces each macro with its value.
{% endhint %}

### Compilation

The next step is to run the compiler on `charcount.i`. We do so with the following command:

```
gcc217 -S charcount.i
```

The output is assembly language file `charcount.s`. Let's break down what takes place during this stage.

#### Error Checking

First, the compiler checks for syntax errors in our code. Syntax errors occur if you don’t follow the grammar rules of the C language. For example, forgetting a semicolon or a curly brace. Thankfully we don’t have any syntax errors, but if we did, the compiler would report the errors and terminate.

Next, the compiler checks for semantic errors. Semantic errors occur when the syntax is correct, but you attempt to perform an illegal operation, such as using a variable before it is declared or passing a ... to a function that expects a ... Here, the compiler uses the declarations of `printf` and `getchar` that were inserted into our program during the preprocessing stage to ensure that the functions are called correctly. Noye that a call to an undefined function is perfectly valid. 

#### Translation to Assembly

Assuming the compiler does not detect any errors in our program, the compiler then moves on to translating our C code in assembly. assembly language is not a specific language like C. lIt it then translates it into assembly language. Assembly language is essentially a human-readable version of the target processor's machine language. As such, the precise assembly language generated by the compiler will depend on the architecture of the target processor. On an ARM64 machine, the assembly will look something like this:

{% code title="charcount.s" %}
```armasm
.LC0:
        .string "%d\n"
main:
        stp     x29, x30, [sp, -32]!
        mov     x29, sp
        str     wzr, [sp, 24]
        bl      getchar
        str     w0, [sp, 28]
        b       .L2
.L3:
        ldr     w0, [sp, 24]
        add     w0, w0, 1
        str     w0, [sp, 24]
        bl      getchar
        str     w0, [sp, 28]
.L2:
        ldr     w0, [sp, 28]
        cmn     w0, #1
        bne     .L3
        ldr     w1, [sp, 24]
        adrp    x0, .LC0
        add     x0, x0, :lo12:.LC0
        bl      printf
        mov     w0, 0
        ldp     x29, x30, [sp], 32
        ret
```
{% endcode %}

You don't need to understand what any of this means. ARM64 assembly will be covered in detail in the second half of COS217. For now, a few points are worth noting.

*   Each assembly instruction performs a very basic task, such as adding two numbers or moving data from one memory location to another. As such, it has a poor ratio of functionality to code size compared to higher-level languages like C. In our example, the simple statement getChar++ maps to four ARM assembly instructions:

    ```armasm
    LDR     w0, [sp, 24]
    ADD     w0, w0, 1
    STR     w0, [sp, 24]
    ```
* Assembly language gives you total control over the CPU. Some operations possible in assembly have no high-level language equivalent. This allows you to optimize performance and resource usage to a degree not possible in higher-level languages.
* One of the main drawbacks of assembly is that it's not portable. Unlike high-level languages like C, \<fill in>.
