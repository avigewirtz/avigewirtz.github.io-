# Example: Single-file Program

Let's walk through the four-stage process of building the \`charcount.c\` program. Instead of using the all-in-one shortcut command to build it, let’s invoke each stage individually, similar to how it happens under the hood.&#x20;

{% code title="charcount.c" %}
```c
#include <stdio.h>

/* Write to stdout the number of chars in stdin. Return 0. */
int main(void) {
    int c;
    int charCount = 0;

    c = getchar();
    while (c != EOF) {
        charCount++;
        c = getchar();
    }

    printf("%d\n", charCount);
    return 0;
}
```
{% endcode %}

#### Preprocessing

The first step to building our program is to preprocess it. The command to invoke the preprocessor is:&#x20;

```bash
gcc217 -E charcount.c -o charcount.i
```

The result is the preprocessed file `charcount.i`. As we mentioned earlier, the preprocessor performs two main tasks: It removes comments, which are of no use to the compiler, and handles preprocessor directives (lines in the code that begin with a `#`). `charcount.c` has only a single preprocessor directive: `#include <stdio.h>`. This directive instructs the preprocessor to grab the contents of `stdio.h` and paste it directly in the spot in `charcount.c` where the `#include` directive appears. stdio.h is a system header file representing an interface for standard I/O functions. We'll get into the details in the next section, but for now, all you need to know is that whenever a program uses functionality from C standard I/O, it needs to #include stdio.h in it.

The entire file is quite large, containing somewhere on the order of 1000 lines. It contains declarations of standard I/O functions, such as printf.&#x20;

```c
int printf(const char *format, ...);
```

Additionally, it contains the definition of EOF.&#x20;

```c
#define EOF -1
```



You can view the preprocessed output in `charcount.i` using a text editor like emacs. It should look something like this:

{% hint style="success" %}
You can think of the preprocessor as a "search-and-replace" tool:

* It replaces each comment with a whitespace character.
* It replaces each `#include` directive with the contents of the specified file.
* It replaces each macro with its value.
{% endhint %}

#### Compilation&#x20;

The next step is to run the compiler on `charcount.i`. The compiler two main things. First, it checks for errors in the program. If it finds any, it reports them to the user and terminates. If it does not detect any errors, it translates the preprocessed C code into assembly.&#x20;

We run the compiler on `charcount.i` with the following command:

```
gcc217 -S charcount.i
```

The output is assembly language file `charcount.s`. Let's break down what takes place behind the scenes during this stage.

#### Error Checking

Before the compiler translates the code to assembly, it first checks for errors in the C code. The compiler first checks for syntax errors. Syntax errors are caused by not following these grammar rules of the language. For example, forgetting a semicolon after a statement or a closing brace after a function will yield a syntax errors. Syntax errors are generally easy to fix.&#x20;





Assembly language is essentially a human-readable version of the target processor's machine language. As such, the precise assembly language generated by the compiler depends on the architecture of the target processor. Figure 14 shows what the assembly output might look like on an ARM64 machine, such as Armlab.





{% hint style="info" %}
#### Characteristics of Assembly language

Detailed coverage of assembly language is beyond the scope of this chapter. ARM64 assembly will be covered in detail in the second half of COS217. For now, we will make a few general points about assembly.

*   Each assembly instruction performs a very basic task, such as adding two numbers or moving data from one memory location to another. As such, it has a poor ratio of functionality to code size compared to higher-level languages like C. For example, the C statement `x = y + z` requires four ARM assembly instructions:

    ```armasm
    LDR X0, [y]      ; Load the value of y into register X0 
    LDR X1, [z]      ; Load the value of z into register X1
    ADD X0, X0, X1   ; Add the values in X0 and X1, store result in X0
    STR X0, [x]      ; Store the result from X0 into the variable x
    ```
* Assembly language gives you total control over the CPU. Some operations possible in assembly have no high-level language equivalent. This allows you to optimize performance and resource usage to a degree not possible in higher-level languages.
* One of the main drawbacks of assembly is that it's not portable. Unlike high-level languages like C, \<fill in>.
{% endhint %}





{% hint style="info" %}
**Understanding the Role of Header Files**

Our program uses the printf function, which is not defined anuywhere in our source code. The definition of printf will be inserted by the linker, which operates in the last stage of the build process. This means that during the first three phases of the build process, the definition of `printf` is not known.

This scheme, in which externally defined functions like `printf` are inserted into the program at the end of the build process, has many benefits – most notably, it saves us the time of having to recompile printf every time we use it. However, this scheme does present a challenge. One of the compiler's jobs is to type-check function calls, ensuring they are called with the correct number and types of arguments and return the correct type. Without access to the printf definition, how does the compiler obtain this information?

The solution is that we insert the declaration of printf into our program before compilation begins. The declaration for printf is: \<fll in>.This specifies its function's name, return type, and the number and types of its arguments. It's a way of informing the compiler, "\<fill in." This enables the compiler to generate correct code for function calls and detect potential errors even without the function definition.&#x20;

In the early days of C, before the preprocessor existed, programmers had to manually insert the signatures of any externally defined functions their program used. As you can imagine, this was tedious and error-prone. For example, if your program used 20 externally defined functions, you would have to add all their declarations at the top of your file. Worse yet, if one of them changed and you didn't update it, subtle and hard-to-find runtime errors could occur.

The solution was to adopt a file-inclusion mechanism. In this scheme, related declarations are bundled into a header file. For example, all standard I/O functions are bundled into the header file `stdio.h`. Now, to use I/O library functions, you simply `#include <stdio.h>` in your file, rather than manually adding all the relevant declarations. If any of the declarations in `stdio.h` change, the updated information will be automatically added to your file the next time it's compiled. If any of the updates cause an error, it will be caught at compile time rather than runtime.
{% endhint %}







